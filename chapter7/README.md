# 第7章 組とパターンマッチ

### 7.1 組の構文
組は、幾つかのデータを並べて一つのデータにしたもの。わかり易い例は、2つの実数を並べてつくった2次元平面上の点。
Ocamlにおいて、組は要素の値をカンマで区切って表現する。

```ml
(3.14, 2.71) ;;
- : float * float = (3.14, 2.71)
```

組の方は要素の型を * で区切ったものになる。
組は違う要素の型を並べても、3つ以上の要素を並べてもいい。

```ml
# (3, true) ;;
- : int * bool = (3, true)

# (3, "a", 3.14) ;;
- : int * string * float = (3, "a", 3.14)
```

 組の要素は基本的な方である必要はない。
 例えば、組の組も作ることができる。

```ml
# ((3, "a"), 3.14) ;;
- : (int * string) * float = ((3, "a"), 3.14)
```

これは「整数と文字列の組」と「実数」という2つの要素の組。
Ocamlの組は、カッコを使って表すのが普通だが、カンマがあればカッコは省略できる。
例えば次のように書くと3.14と2.71の組になる。

```ml
# 3.14, 2.71 ;;
- : float * float = (3.14, 2.71)
```

しかし、このようにカッコを省略してもプログラムが読みにくくなるだけで利点はない。
組を使うときは必ずカッコで全体をくくるようにしたほうがいい。

--------

# Exercise
国語、数学、英語、理科、社会の5教科の点数を与えられたら、その合計点と平均点を組にして返す関数sumAndAverageを定義せよ。

```ml
# let sumAndAvarage score =
  sum = socre1 +. socre2 +. socre3 +. score4 +. score5
  avarage = sum / 5 ;;
```

### 7.2 パターンマッチ
組を使うと複数のデータをひとつにまとめて、あたかもひとつのデータであるかのように扱える。
組にかぎらず複数のデータからできているデータの中身を取り出すには*パターンマッチ（パターンの照合）*を使う。

```ml
match 式 with
  パターン -> 式
```

このように書くと、最初にmatchとwithにはさまれた式を実行し、その結果をパターンと照合する。
パターンとはデータの形（パターン）を指定するもの。そしてその照合結果を使い、最後の式を実行する。
(3, 5)という組の要素を取り出すには次のようにする。

```ml

# match (3, 5) with
  (a, b) -> a + b ;;
- : int = 8
```

このプログラムは、(3, 5)という組からパターンマッチを使って要素を取り出し、それらを加えた結果を返す。
(a, b)というのがふたつの値の組を表すパターンになる。

ここに出てくるaとbは*パターン変数*と呼ばれ、構造データの要素を取り出すのに使われる。
(3, 5)という組が(a, b)というパターンと照合されると、パターン変数aの値が3に、bの値が5になります。
これで組の要素をaとbというパターン変数に取り出すことができる。
そのうえで矢印の右側の式が実行される。矢印の右側では普通の変数に加え、パターン変数も自由に使うことができる。

上の例では、組を作った直後にパターンマッチで要素を取り出したが、組を作るのと要素を取り出すのは別にするのが普通。
そこで、ふたつを別にした関数を定義する。

```ml
# let add pair = match pair with
  (a, b) -> a + b ;;
val add : int * int -> int = <fun>
```

関数addは引数としてpairを受け取り、このpairは必ず2つの整数の組でなければならない。
なぜなら、その後のmatch文で(a, b)という組とパターンマッチされるため。
この関数を使って組(3, 5)の要素を加えるなら以下になる。

```ml
# add (3, 5) ;;
- : int = 8
```

Ocamlの関数定義は、引数にパターンを書ける。
そのため上の定義は以下のようにも書ける。

```ml
# let add (a, b) = a + b ;;
val add : int * int -> int = <fun>
```

これで(a, b)というパターンが引数の役割もしている。
この定義と最初の定義の違いは、関数の本体でpairという変数を使うことができるかという点。
下の書き方はプログラムを短くできるが、デザインレシピでは引数にパターンを書く方法は使わない。

match文や関数の引数のパターンを書く際は、「パターン変数はお互い異なっていなくてはならない」という制限がある。
以下のようにすれば、引数pairとして2つの整数の組で、かつ2つの値が等しいもののみを受け取ってくる関数を定義できる。

```ml
# let f pair = match pair with
  (a, a) -> a + a ;;
Error: Variable a is bound several times in this matching
```

しかし、パターン変数はお互いに異ならなくてはならないため、エラーが起きる。
どういう時に組として受け取ればいいかというと、それはふたつの受け取ってくる値が意味的に一つのものを表しているかによる。
座標平面上のx座標とy座標の要な場合は組として受け取り、関係のない値であれば別々に受け取る。

--------

# Exercise
名前と成績の組を受け取ったら「◯◯さんの評価は△です」という文字列を返す関数resultを定義せよ。

```ml
# let result (name, score) =
  name ^ "さんの評価は" ^ score ^ "です。" ;;
val result : string * string -> string = <fun>
```

### 7.3 構造データに対するデザインレシピ

組のようなデータ構造を扱うと、入出力のデータ型が複雑になってくる。
また、プログラム中ではその構造にしたがってデータを分離し、中身にアクセスする必要もある。
構造を持つデータを扱うときは、「目的」、「例」、「テンプレート」、「本体」、「テスト」の形のデザインレシピにする。

テンプレートとは、入力データの型から必然的に決まってくるプログラムの雛形。
関数本体を作る前にテンプレートを作ると関数本体の作成が格段に楽になる。

関数addの目的と例をデザインレシピにしたがって作ると以下になる。

```ml
(* 目的：2つの整数の組pairを受け取りその整数の和を返す *)
(* add : int * int -> int *)
let add pair = 0

(* テスト *)
let test1 = add (0, 0) = 0
let test2 = add (3, 5) = 8
let test3 = add (3, -5) = -2
```

入力の方が構造データである組になっている。
そこでテンプレートを作成します。入力の方はint * intなのでプログラムは以下になる。

```ml
(* 目的：2つの整数の組pairを受け取りその整数の和を返す *)
(* add : int * int -> int *)
let add pair = match pair with
  (a, b) -> 0
```

テンプレートは入力の型さえ決まれば、どんな関数でも挿入できる。

このようなテンプレートをつくっておくと、関数の本体を作る際に引数pairのひとつ目の関数、ふたつ目の関数をすぐに使える。
それぞれパターン変数aとbを使えばいい。
あらかじめテンプレートを書くことのメリットは、本体を作る時に利用できる値が明確になること。
最初の`let add pair = 0`というヘッダだけではpairという変数しか使えないが、上のものはaとbというパターン変数も使える。
テンプレートが完成したら、テストも書く。

```ml
# use "add.ml" ;;
val add : 'a * 'b -> int = <fun>
val test1 : bool = true
val test2 : bool = false
val test3 : bool = false
```

テンプレートができれば関数の本体を作るのは簡単。

```ml
(* 目的：2つの整数の組pairを受け取りその整数の和を返す *)
(* add : int * int -> int *)
let add pair = match pair with
  (a, b) -> a + b
```

--------

# Exercise
x座標とy座標の組で表された平面座標を受け取ったら、x軸について対称な点の座標を返す関数symmetry_xをデザインレシピにしたがって作れ。

```ml
(* 目的：x座標、y座標を受け取り、x座標の対称な点の座標を返す *)
(* add : int * int -> int *)
let symmetry_x point = match point with
  (x, y) -> (-. x, y)

(* テスト *)
let test1 = symmetry_x (2, 9) = (-2, 9)
let test1 = symmetry_x (-2, 4) = (2, 4)
```


x座標とy座標の組で表された平面座標をふたつ受け取ったら、その中点の座標を返す関数midpointをデザインレシピにしたがって作れ。

```ml
(* 目的：x座標、y座標を受け取り、中点の座標を返す *)
(* add : int * int -> int *)
let midpoint point = match point with
  ((x1, y1), (x2, y2)) -> ((x1 +. x2) /. 2), ((y1 +. y2) /. 2)

(* テスト *)
let test1 = midpoint ((2, 5), (1, 10)) = (1.5, 7.5)
let test2 = midpoint ((-2, 4), (4, -8)) = (1, -2)
```

### 7.4 パターンマッチの実行方法

最後にパターンマッチの実行方法を見る。
以下のような式を考える。

```ml
match (2 + 3, 4 - 1) with
  (a, b) -> a + b
```

これは(2 + 3, 4 - 1)という組の要素をパターンマッチで取り出し、それらを加えるプログラム。
パターンマッチはまずmatchとwithではさまれたマッチされる式の実行から始まる。
結果として以下のようになる。

```ml
match (5, 3) with
  (a, b) -> a + b
```

マッチされる式の実行が完全に終了したら、次にパターンと照合する。
パターン変数aが5に、bが3にマッチする。
そのうえで、match文全体を矢印の右側の式で置き換える。その際、パターン変数はマッチした値に置き換えられる。
よって5 + 3が行われ、8が得られる。
